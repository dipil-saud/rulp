# Rulp

Rulp is an easy to use Ruby DSL for generating linear programming and mixed integer programming problem descriptions in the LP file format.

The *[.lp]* file format can be read and executed by most LP solvers including Coin-Cbc, Scip, GLPK and Gurobi.

Rulp will execute and parse the results generated by **Cbc**, **Scip** and **GLPK**.

Rulp is inspired by the ruby wrapper for the GLPK toolkit and the python LP library "pulp".

## Sample Code

	# maximize
	#   z = 10 * x + 6 * y + 4 * z
	#
	# subject to
	#   p:      x +     y +     z <= 100
	#   q: 10 * x + 4 * y + 5 * z <= 600
	#   r:  2 * x + 2 * y + 6 * z <= 300
	#
	# where all variables are non-negative integers
	#   x >= 0, y >= 0, z >= 0
	#


	given[

	X_i >= 0,
	Y_i >= 0,
	Z_i >= 0

	]

	result = Rulp::Cbc Rulp::Max( 10 * X_i + 6 * Y_i + 4 * Z_i ) [
	                X_i +     Y_i +     Z_i <= 100,
	           10 * X_i + 4 * Y_i + 5 * Z_i <= 600,
	           2 *  X_i + 2 * Y_i + 6 * Z_i <= 300
	].solve

	##
	# 'result' is the result of the objective function.
	# You can retrieve the values of variables by using the 'value' method
	# E.g
	#   X_i.value == 32
	#   Y_i.value == 67
	#   Z_i.value == 0
	##


## Usage

#### Variables

	# Rulp variables are initialized as soon as they are needed so there is no
	# need to initialize them.
	# They follow a naming convention that defines their type.
	# A variable is declared as a constant with one of three different suffixes.
	# 'f' or '_f' indicates a general variable (No constraints)
	# 'i' or '_i' indicates a integer variable
	# 'b' or '_b' indicates a binary/boolean variable


	An_Integer_i
	=> #<IV:0x007ffc4b651b80 @name="An_Integer">

	Generalf
	=> #<LV:0x007ffc4b651b80 @name="General">

	Bool_Val_b
	=> #<BV:0x007ffc4b67b6b0 @name="Bool_Val">

	# In some cases it is implausible to generate a unique name for every possible variable
	# as an LP problem description may contain many hundreds of variables.
	# To handle these scenarios variable definitions can
	# accept index parameters to create large ranges of unique variables.
	# Examples of how indexed variables can be declared are as follows:

	Item_i(4,5)
	#<IV:0x007ffc4b3ea518 @name="Item4_5">

	Item_i("store_3", "table_2")
	#<IV:0x007ffc4b3a3cd0 @name="Itemstore_3_table_2">

	[*0..10].map(&Unit_f)
	=> [#<LV:0x007ffc4cc25768 @name="Unit0">,
	 #<LV:0x007ffc4cc24cf0 @name="Unit1">,
	 #<LV:0x007ffc4cc0fc88 @name="Unit2">,
	 #<LV:0x007ffc4cc0f260 @name="Unit3">,
	 #<LV:0x007ffc4cc0ecc0 @name="Unit4">,
	 #<LV:0x007ffc4cc0e748 @name="Unit5">,
	 #<LV:0x007ffc4cc0df50 @name="Unit6">,
	 #<LV:0x007ffc4cc0d9d8 @name="Unit7">,
	 #<LV:0x007ffc4cc0d460 @name="Unit8">,
	 #<LV:0x007ffc4cc0cee8 @name="Unit9">,
	 #<LV:0x007ffc4cc0c970 @name="Unit10">]


### Variable Constraints

Add variable constraints to a variable using the <,>,<=,>=,== operators.
Be careful to use '==' and not '=' when expressing equality.
Constraints on a variable can only use numeric literals and not other variables.
Inter-variable constraints should be expressed as problem constrants. (Explained below.)

	X_i < 5
	X_i.bounds
	=> "X <= 5"

	3 <= X_i < 15
	X_i.bounds
	=> "3 <= X <= 15"

	Y_f == 10
	Y_f.bounds
	=> "y = 10"

### Problem constraints

Constraints are added to a problem using the :[] syntax.

	problem = Rulp::Cbc Rulp::Max( 10 * X_i + 6 * Y_i + 4 * Z_i )

	problem[
		X_i +     Y_i +     Z_i <= 100
	]

	problem[
		10 * X_i + 4 * Y_i + 5 * Z_i <= 600
	]
	...
	problem.solve

You can add multiple constraints at once by comma separating them as seen in the earlier examples:

	Rulp::Cbc Rulp::Max( 10 * X_i + 6 * Y_i + 4 * Z_i ) [
		                X_i +     Y_i +     Z_i <= 100,
		           10 * X_i + 4 * Y_i + 5 * Z_i <= 600,
		           2 *  X_i + 2 * Y_i + 6 * Z_i <= 300
		          ]

### Solving or saving 'lp' files

There are multiple ways to solve the problem or output the problem to an 'lp' file.
Currently the RULP library supports calling installed executables for Scip, Cbc and glpk.
For each of these solvers it requires the following executables to be installed respectively
such that the command `which [exec_name]` returns a path. (I.e they must be on your PATH).
(scip, cbc, glpsol)

Given a problem there are multiple ways to initiate a solver.

	@problem = Rulp::Cbc Rulp::Max( 10 * X_i + 6 * Y_i + 4 * Z_i ) [
	                 X_i +     Y_i +     Z_i <= 100,
	           	10 * X_i + 4 * Y_i + 5 * Z_i <= 600,
	           	2 *  X_i + 2 * Y_i + 6 * Z_i <= 300
						]

Default solver:

	@problem.solve
	# this will use the solver specified in the environment variable 'SOLVER' by default.
	# This can be 'scip', 'cbc', or 'glpk'. If no variable is given it uses scip as a default.

If you had a linear equation in a file named 'problem.rb' from the command line you could specify an alternate solver by executing:

	SOLVER=cbc ruby problem.rb

Explicit solver:

	@problem.scip
	# 	Or
	@problem.cbc
	#   Or
	@problem.glpk

Or

	Rulp::Scip(@problem)
	Rulp::Glpk(@problem)
	Rulp::Cbc(@problem)


For debugging purposes you may wish to see the input and output files generated and consumed by Rulp.
To do this you can use the following extended syntax:

	def solve_with(type, open_definition=false, open_solution=false)...

The optional booleans will optionally call the 'open' utility to open the problem definition or the solution. (This utility is installed by default on a mac and will not work if the utility is not on your PATH)


	@problem.solve_with(SCIP, true, true)

#### Saving LP files.

You may not wish to use one of the RULP compatible but another solver that is able to read .lp files. (E.g CPLEX of Gurobi) but still want to use Rulp to generate your LP file. In this case you should use Rulp to output your lp problem description to a file of your choice. To do this simply use the following call

	@problem.save("/Users/johndoe/Desktop/myproblem.lp")

OR

	@problem.output("/Users/johndoe/Desktop/myproblem.lp")

You should also be able to call

	@problem.save

Without parameters to be prompted for a save location.

### Examples.
Take a look at some basic examples in the ./examples directory in the source code.

### Rulp Executable
Rulp comes bundled with a 'rulp' executable which by default loads the rulp environment and either the PRY or IRB REPL.
(Preference for PRY). Once installed you should be able to simply execute 'rulp' to launch this rulp enabled REPL.
You can then play with and attempt LP and MIP problems straight from the command line.

	[1] pry(main)> 13 <= X_i <= 45 # Declare integer variable
	=> X(i)[undefined]

	[2] pry(main)> -15 <= Y_f <= 15 # Declare float variable
	=> Y(f)[undefined]

	[3] pry(main)> @problem = Rulp::Min(X_i - Y_f) # Create min problem
	[info] Creating minimization problem
	=>
	Minimize
	 obj: X -Y
	Subject to
	0 X = 0
	Bounds
	 13 <= X <= 45
	 -15 <= Y <= 15
	General
	 X
	End

	[4] @problem[ X_i - 2 * Y_f < 40] #Adding a problem constraint
	=>
	Minimize
	 obj: X -Y
	Subject to
	  c0: X -2 Y <= 40
	Bounds
	 13 <= X <= 45
	 -15 <= Y <= 15
	General
	 X
	End


	[5] pry(main)> @problem.solve # Solve
	...
	[info] Solver took 0.12337
	[info] Parsing result
	=> -2.0 #(Minimal result)

	[6] pry(main)> Y_f # See value calculated for Y now that solver has run
	=> Y(f)[15.0]

	[8] pry(main)> X_i
	=> X(i)[13.0]

	# The result of the objective function (-2.0) was returned by the call to .solve
	# Now the solver has run and calculated values for our variables we can also test the
	# objective function (or any function) by calling evaluate on it.
	# E.g

	[9] (X_i - Y_f).evaluate
	=> -2.0

	[10] pry(main)> (2 * X_i + 15 * Y_f).evaluate
	=> 251.0