# Rulp

Rulp is an easy to use Ruby DSL for generating linear programming and mixed integer programming problem descriptions in the LP file format.

The *[.lp]* file format can be read and executed by most LP solvers including Coin-Cbc, Scip, GLPK and Gurobi.

Rulp will execute and parse the results generated by **Cbc**, **Scip** and **GLPK**.

Rulp is inspired by the ruby wrapper for the GLPK toolkit and the python LP library "pulp".

## Sample Code

	# maximize
	#   z = 10 * x + 6 * y + 4 * z
	#
	# subject to
	#   p:      x +     y +     z <= 100
	#   q: 10 * x + 4 * y + 5 * z <= 600
	#   r:  2 * x + 2 * y + 6 * z <= 300
	#
	# where all variables are non-negative integers
	#   x >= 0, y >= 0, z >= 0
	#


	given[

	X_i >= 0,
	Y_i >= 0,
	Z_i >= 0

	]

	result = Rulp::Cbc Rulp::Max( 10 * X_i + 6 * Y_i + 4 * Z_i ) [
	                X_i +     Y_i +     Z_i <= 100,
	           10 * X_i + 4 * Y_i + 5 * Z_i <= 600,
	           2 *  X_i + 2 * Y_i + 6 * Z_i <= 300
	]

	##
	# 'result' is the result of the objective function.
	# You can retrieve the values of variables by using the 'value' method
	# E.g
	#   X_i.value == 32
	#   Y_i.value == 67
	#   Z_i.value == 0
	##


## Usage

#### Variables

	# Rulp variables are initialized as soon as they are needed so there is no
	# need to initialize them.
	# They follow a naming convention that defines their type.
	# A variable is declared as a constant with one of three different suffixes.
	# 'f' or '_f' indicates a general variable (No constraints)
	# 'i' or '_i' indicates a integer variable
	# 'b' or '_b' indicates a binary/boolean variable


	An_Integer_i
	=> #<IV:0x007ffc4b651b80 @name="An_Integer">

	Generalf
	=> #<LV:0x007ffc4b651b80 @name="General">

	Bool_Val_b
	=> #<BV:0x007ffc4b67b6b0 @name="Bool_Val">

	# In some cases it is implausible to generate a unique name for every possible variable
	# as an LP problem description may contain many hundreds of variables.
	# To handle these scenarios variable definitions can
	# accept index parameters to create large ranges of unique variables.
	# Examples of how indexed variables can be declared are as follows:

	Item_i(4,5)
	#<IV:0x007ffc4b3ea518 @name="Item4_5">

	Item_i("store_3", "table_2")
	#<IV:0x007ffc4b3a3cd0 @name="Itemstore_3_table_2">

	[*0..10].map(&Unit_f)
	=> [#<LV:0x007ffc4cc25768 @name="Unit0">,
	 #<LV:0x007ffc4cc24cf0 @name="Unit1">,
	 #<LV:0x007ffc4cc0fc88 @name="Unit2">,
	 #<LV:0x007ffc4cc0f260 @name="Unit3">,
	 #<LV:0x007ffc4cc0ecc0 @name="Unit4">,
	 #<LV:0x007ffc4cc0e748 @name="Unit5">,
	 #<LV:0x007ffc4cc0df50 @name="Unit6">,
	 #<LV:0x007ffc4cc0d9d8 @name="Unit7">,
	 #<LV:0x007ffc4cc0d460 @name="Unit8">,
	 #<LV:0x007ffc4cc0cee8 @name="Unit9">,
	 #<LV:0x007ffc4cc0c970 @name="Unit10">]


### Variable Constraints

Add variable constraints to a variable using the <,>,<=,>=,== operators.
Be careful to use '==' and not '=' when expressing equality.
Constraints on a variable can only use numeric literals and not other variables.
Inter-variable constraints should be expressed as problem constrants. (Explained below.)

	X_i < 5
	X_i.bounds
	=> "X <= 5"

	3 <= X_i < 15
	X_i.bounds
	=> "3 <= X <= 15"

	Y_f == 10
	Y_f.bounds
	=> "y = 10"

